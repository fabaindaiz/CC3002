Tarea CC3002 v2.0

Empezando
    Este proyecto tiene por finalidad cumplir con las tareas de CC3002 para este semestre
    Actualmente está implementado hasta lo pedido en el segundo enunciado
    Cualquier información no disponible en este documento se podra encontrar en la documentación de las clases y metodos

Requisitos
    Para ejecutar el proyecto se necesita tener java 11 o superior instalado (JDK)
    Actualmente lo único funcional del proyecto son las test y se deben correr en un IDE con JUnit 5

Descripción del proyecto
    Esta tarea fue hecha considerando lo visto en CC3002

    Se implementaron 8 interfaces principales:
        IUnit e IEquipableItem: Unidades e Items
        IField:                 Mapa de la partida
        ITactician:             Jugador de la partida
        IGameController:        Controlador de la partida
        IParameter:             Parametros de configuración de la partida
        IObserver e ISubject:   Observador y Sujeto observado

    Se implemento usando un patrón de diseño MVC (Modelo-Vista-Controlador)
    A continuación se menciona a que parte del diseño pertenece cada interfaz
        M (Modelo):
            IUnit
            IEquipableItem
            IField
            ITactician
        V (Vista):
        C (Controlador):
            IGameController
            IParameter
            IObserver
            ISubject

    Estructura interna del Modelo:
    Cada interfaz posee una clase abstracta principal

    Todas las armas y unidades similares están implementadas con clases abstractas asociadas a su clase abstracta principal
    Estas clases abstractas son implementadas por una clase especifica por cada arma o unidad existente
    Esto se hizo a fin de facilitar futuras implementaciones en el proyecto

    Para ejecutar diferentes acciones dependiendo del caso como en los ataques o en los test, se usó Double Dispatch
    Esto permite tener funciones en cada clase que generan un comportamiento distinto según sea requerido

    El mapa fue creado como un objeto que contiene los nodos en un Map<Location> y metodos para crearse de forma aleatoria

    Estructura interna de la Vista:

    Estructura interna del Controlador:
    Cada interfaz posee una clase abtracta principal
    (Excepto IObserver, ya que todos los observer son completamente independientes en funcionalidad)

    Ademas, existe una única clase abstracta que no posee interfaz llamada GameInitializatión
    Esta se encarga de inicializar lo necesario para una nueva partida al llamarse InitGame


Decisiones relevantes
    Se enumeraran a continuación todas las decisiones no mencionadas en la descripción que se tomaron al realizar el proyecto

    Comentarios para la Entrega 1:
    - Se crearon clases abstractas para agrupar armas y unidades similares para facilitar futuras implementaciones
        Asi, se redujo el codigo duplicado en situaciones similares, como al equipar un MagicBook en Sorcerer
        o al atacar a unidades que tengan armas con las mismas debilidades, como Magias vs Armas normales.

    - Para el contraataque, se optó por tener el método ataque con un parámetro boolean que indica si es necesario
        Además, las armas poseen un método que indica si son armas que realizas contraataque o no.

    - Los sistemas de daño modificado se implementaron como métodos en las distintas armas
        Así además, según el arma que ataca se llama a un método de daño en la unidad distinto según el caso
        Se implemento la curación, como una llamada que se realiza al recibirse un ataque con Staff

    - Los sistemas de equipados de items se hizo con Double Dispatch.
        Cada arma es llamada al momento de ser equipada y devuelve un llamado a la unidad dependiendo de su tipo

    - Los ataques son recibidos y ejecutados por el arma equipada, desligando esto de las unidades
        (En un inicio se pensó usar una clase ataque, pero se descartó para usar esta implementación)
    - El aumento y disminución de valores y la verificaciones de armas son las únicas partes del combate
        que se implementaron en la unidad, esto con fin de evitar problemas con unidades sin armas
        (Una posible propuesta fue implementar una clase "nullWeapon", pero se descartó por esta idea)
    - Toda unidad sin arma equipada recibe daño sin modificar, esto se ejecuta directamente en la unidad

    - Una unidad muerta simplemente posee localización nula, así nadie puede interactuar con ella
        Se verifica además que ninguna función pueda ejecutarse o falle por puntero nulo
        EDIT entrega 2: Cuando una unidad muere, es eliminada del Tactician por IObserver

    - No se modifico nada del Template en model.map

    Comentarios para la Entrega 2:
    - Todas las clases nuevas son parte del controlador, a excepcion de la clase Tactician que es parte de modelo

    - Se decidio crear una interfaz para cada clase del controlador, esto para agrupar toda la documentación en la interfaz
        Esto no era necesario en GameController y Tactician, pero ayuda a evitar muchas cosas en la clase principal

    - Ademas, para los Observer y Parameter, era necesario agruparlos en una interfaz por su funcionamiento
        Esto para cuando se guardan en ArrayList que pueden tener varios Observer o Parameter

    - De decidio crear una clase separada para guardar las variables del juego necesarias para inicializarlo
        Esto para simplificarme la inicialización de una nueva partida y el almacenamiento de Parameter

    - Para inicializar la partida se decidio crear una clase llamada Parameter, que almacena todos los parametros de la partida
        Su uso es almacenar todas las unidades e items creadas antes de initGame, para poder volver a este estado
        Estos Parameter se guardan en un List, y poseen un metodo para crearse a si mismos en la nueva partida
        Se separaron los parametros en dos tipos: UnitParameter e ItemParameter, ambos con su propio metodo create()

    - Se decidio crear el metodo que genera el mapa en la clase Field, con un metodo que puede ser llamado desde GameController
        Esto porque el mapa tiene todos los datos necesarios para crearse a si mismo una vez es llamado

    -

    - Se creo una clase Observer muy simple para realizar las tareas de verificar derrota de Tactician o Unit
        Se crearon 3 subclases para cada caso que necesita ser observado.

Testeo
    Los test están implementados con JUnit 5

    Fueron creados test para todas clases y metodos del programa en variados casos estandares y bordes
    Existen 351 test en total y todas las clases del programa cumplen con un coverage del 100%

    Los test demoran entre 1.5 y 2 segundos en correr en mi pc (Portatil Windows i7 8gb ssd)
    El test que más tiempo demora en completarse es BenchmarkGenerateMap (entre 1 y 1.5 segundos)

    Las unicas funcionalidades sin test directo, pero con varios test indirectos son
        - En IField, el generador de mapa no posee un test directo
            Su funcionalidad se prueba en muchos test de IGameController, IObserver, entre otros
            Aca se verifica las invariantes del objeto y distintos casos bordes
        - En GameInitialization, el metodo InitAll no se testea directamente
            Su funcionalidad se testea directa e indirectamente por muchos otros test en casi todas las clases
            Si presentara un error, simplemente muchos test no pasarian, ya que es la parte principal del juego
        - Muchos setters y getters no tiene test directos pero si test indirectos que los verifican

    Test del Modelo:
    Cada arma se testea con los mismos test básicos que verifican su correcto funcionamiento
    En esta parte no han habido muchos cambios desde el template además de añadir los test para las armas nuevas

    Cada Unidad se testea con los mismos test completos que verifican su correcto funcionamiento
    En esta parte se verifican todas las funcionalidades de las unidades con diferentes test
    También se verifica el sistema de armas y fortalezas en diversas pruebas de ataque y contraataque

    En el testeo, cada unidad con cada arma ataca a el resto de forma independiente, verificando así el funcionamiento completo
    Además, en cada test especifico se han añadido casos de borde para verificar que ninguna método falle en estos

    Los test del mapa se mantuvieron igual a como estaban en el Template usado

    EDIT entrega 2: Se añadieron los test de los nuevos metodos definidos en IUnit para el funcionamiento del modelo

    Se testean los metodos de ITactician de forma individual, para verificar su funcionalidad principal
    La mayoria de los test son iguales a los test definidos para los metodos de IGameController
    Esto porque algunos metodos de IGameController llaman directamente a los emtodos en ITactician

    No se añadieron nuevos test a los metodos de IField, ya que aunque se añadieron funcionalidades al mapa
    Estos metodos son en su mayoria setters o getters (a excepcion del generador del mapa)

    Test de la Vista:

    Test del Controlador:
    Los metodos de IParameter se testean para cada unidad y su arma equipable para verificar su funcionamiento
    Se añadio un test independiente para parametros nulos, que verifica que ocurre cuando son introducidos datos erroneos

    Los metodos de IObserver se testean de forma general para un par de casos dependiendo del Observer
    Todos los observer se complementan, asi que puede que metodos de un Observer tambie se prueben en otro test

    Los metodos de ISubject se testean de forma completamente indirecta, desde los test de Observer
    Esto porque su funcionalidad es bastante limitada cuando no se usa de forma completa en una partida

    Los metodos de IGame controller
    Estos test se han basado en los test definidos en el template, fueron añadidos algunos test extra
    Las funcionalidades se testean de manera independiente con variados escenarios de casos generales y casos bordes

Hecho con
    Java 12 (compatible con Java 11 o superior)
    Intellij - IDE java
    JUnit 5 - Framework para test

Contribuciones
    Esto es un trabajo personal, sin contribuciones externas

Versionamiento
    Se uso git para el versionamiento. Para ver las versiones disponibles, revisa los Tags o Commits de este repositorio

Autores
    Ignacio Slater Muñoz - Template inicial
    Fabián Díaz González - Trabajo posterior

Licencia
    Este proyecto no posee licencia y puede usarse con cualquier fin